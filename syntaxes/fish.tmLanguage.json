{"name":"fish","scopeName":"source.fish","fileTypes":["fish"],"uuid":"f9278d07-f7c1-4a9b-9581-ebcbc050fbfb","patterns":[{"comment":"Base scope - Pick up '#' and \"\\\\\\n\" before command-call sees them"},{"include":"#comment-external"},{"include":"#line-continuation"},{"comment":"A command can't begin with a close parenthesis. We match this so exclusively early because the command chain scope will end immediately if the close parenthesis is seen by its lookahead; in an ideal world, command-call-standard would be performing this match because fish highlights the strings which follow as arguments. But we can't do that","name":"meta.function-call.fish invalid.illegal.function-call.fish","begin":"\\)","end":"(?=[\\s;&)|<>])"},{"comment":"Anonymous scope - Base scope command chain (up until a newline or ';')","begin":"(?=\\S)","end":"\\n|(;)|(?=\\))","endCaptures":{"1":{"name":"meta.function-call.operator.fish keyword.operator.fish"}},"patterns":[{"comment":"Match an operation which cannot start a command chain (because it is consumed by the command chain when it appears further within it). These are simple control operators and redirections (which conveniently also matches redirection-into-pipe)","name":"invalid.illegal.operator.fish","match":"(?:[&|]|(?:[0-9]+)?(?:<|>>?|\\^\\^?))"},{"comment":"Pick up a comment that has come after an '&'","include":"#comment-internal-end"},{"comment":"Anonymous scope - Base scope command chain (up until an '&'); the reason we match the '&' in a different way is the ';' can be alone on a line, while we must explicitly require that the '&' comes after a command","begin":"(?=\\S)","end":"(?=[\\n;)])|(&)","endCaptures":{"1":{"name":"meta.function-call.operator.fish keyword.operator.fish"}},"patterns":[{"include":"#command-chain"}]}]}],"repository":{"argument":{"patterns":[{"comment":"See the argument-nonoption rule for more information on arguments","begin":"(?![\\s;&)|<>^])","end":"(?=[\\s;&)|<>])","patterns":[{"comment":"Argument starting with two dashes (long option); if the argument is just the two dashes, consider it a short option","name":"meta.argument.fish","begin":"(?=--[^\\s;&)|<>])","end":"(?=[\\s;&)|<>])","patterns":[{"name":"variable.parameter.fish","begin":"(?:--)","beginCaptures":{"0":{"name":"punctuation.definition.parameter.fish meta.string.unquoted.fish"}},"end":"(?=[\\s;&)|<>]|=)","patterns":[{"comment":"We mimic the argument-patterns rule but use a tweaked unquoted string pattern which excludes '='"},{"include":"#command-substitution"},{"name":"meta.string.unquoted.fish","begin":"(?=\\$)","end":"(?!\\$)","patterns":[{"include":"#variable-expansion"}]},{"include":"#string-quoted"},{"name":"meta.string.unquoted.fish","begin":"(?!['\"])","end":"(?=[\\s;&()|<>'\"$]|\\=)","patterns":[{"include":"#string-unquoted-patterns"}]}]},{"comment":"Consume the '=' and then use standard argument patterns as well as numerics","begin":"(?:=)","beginCaptures":{"0":{"name":"variable.parameter.fish punctuation.definition.parameter.separator.fish meta.string.unquoted.fish"}},"end":"(?=[\\s;&)|<>])","patterns":[{"name":"meta.string.unquoted.fish constant.numeric.fish","match":"(?:[+-]?)(?:[0-9]+\\.?[0-9]*|[0-9]*\\.?[0-9]+)(?=[\\s;&)|<>])"},{"include":"#argument-patterns"}]}]},{"comment":"Argument starting with one dash (short option)","name":"meta.argument.fish variable.parameter.fish","begin":"(?:-)(?=[^\\s;&)|<>])","beginCaptures":{"0":{"name":"punctuation.definition.parameter.fish meta.string.unquoted.fish"}},"end":"(?=[\\s;&)|<>])","patterns":[{"include":"#argument-patterns"}]},{"comment":"Argument starting with no dashes"},{"include":"#argument-nonoption"}]}]},"argument-nonoption":{"comment":"This rule must be entirely standalone because it is used in scopes where arguments starting with dashes are explicitly not interpreted as options","patterns":[{"comment":"An argument is a fundamental unit of a command call, defined as a sequence of non-control-operator characters separated by unescaped and unscoped whitespace; begin arg if it does not precede whitespace or a control operator; end arg if it precedes whitespace or control operators (including stdin/stdout redirection but not stderr due to a fish quirk)","name":"meta.argument.fish","begin":"(?![\\s;&)|<>^])","end":"(?=[\\s;&)|<>])","patterns":[{"comment":"Home directory expansion only occurs if the '~' is at the front of the argument","name":"meta.string.unquoted.fish meta.home-directory-expansion.fish keyword.operator.tilde.fish","match":"\\~"},{"comment":"Process expansion only occurs if the '%' is at the front of the argument, and continues for the entire argument","name":"meta.process-expansion.fish","begin":"\\%","beginCaptures":{"0":{"name":"meta.string.unquoted.fish punctuation.definition.process.fish"}},"end":"(?=[\\s;&)|<>])","patterns":[{"comment":"Match special process names. By a convention that I'm making up, scope them as a type of variable","name":"variable.language.fish meta.string.unquoted.fish","match":"(?:self|last)(?=[\\s;&)|<>])"},{"include":"#argument-patterns"}]},{"comment":"Treat a sequence of integers (with possible sign and decimal separator) as a standalone constant. Do this separate to the","name":"meta.string.unquoted.fish constant.numeric.fish","match":"(?:[+-]?)(?:[0-9]+\\.?[0-9]*|[0-9]*\\.?[0-9]+)(?=[\\s;&)|<>])"},{"comment":"Use standard argument patterns exclusively for the remainder of the argument","begin":"(?!\\s)","end":"(?=[\\s;&)|<>])","patterns":[{"include":"#argument-patterns"}]}]}]},"argument-patterns":{"comment":"The typical substitutions, expansions, and escapes allowed anywhere in an argument","patterns":[{"include":"#command-substitution"},{"comment":"Give variable expansion the unquoted string scope","name":"meta.string.unquoted.fish","begin":"(?=\\$)","end":"(?!\\$)","patterns":[{"include":"#variable-expansion"}]},{"comment":"Arguments are otherwise made of strings, either quoted or unquoted. The unquoted string rule handles character escapes and brace expansion"},{"include":"#string"}]},"command-chain":{"comment":"The command-chain rule is nonterminating, meaning that it will not consume a newline, ';', or '&'","patterns":[{"comment":"Match an operation which cannot start a command chain (because it is consumed by the command chain when it appears further within it). These are simple control operators and redirections (which conveniently also matches redirection-into-pipe); TODO - Restructure command-chain so that this match isn't duplicated from the base scope, as it must be for any other scopes which implement their own control operator consumption. Might require the unary operator commands to become an explicit recursive match (though we tried this once and it was more complicated than anything should be)","name":"invalid.illegal.operator.fish","match":"(?:[&|]|(?:[0-9]+)?(?:<|>>?|\\^\\^?))"},{"comment":"Match a unary operator command that isn't allowed within a command chain, only at the beginning. Neglect the match if it is taking an option. Allow line continuation between one of these commands and the next function call; TODO - These commands cannot be followed by backgrounding, piping, or redirection alone. Add logic to catch these cases. It will be extensive...","name":"meta.function-call.fish keyword.operator.word.fish keyword.control.fish","match":"(and|or)\\b(?!\\s+-)"},{"include":"#line-continuation"},{"comment":"This is a hack for now, which allows nesting of 'not' and 'and'/'or' commands. A better solution will be explicit recursivity in these commands","name":"meta.function-call.fish keyword.operator.word.fish keyword.operator.logical.fish keyword.control.fish","match":"(not)\\b(?!\\s+-)"},{"comment":"Added a check for `contains`.","match":"(contains)\\b(?!\\s+-)","captures":{"1":{"name":"keyword.operator.word.fish keyword.operator.logical.fish keyword.control.fish"}}},{"comment":"Match a command which is illegal in the base scope","name":"invalid.illegal.function-call.fish","match":"(?:case|else|end)(?=[\\s;&)|<>])"},{"comment":"Anonymous scope - Command chain. Define a command chain as either one command call, or multiple command calls linked by piping ('|', '2>|', etc). The chain terminates at the first encounter of any other control operator (newline, ';', '&') or the implied newline of the closing parenthesis of a command substitution","begin":"(?=[^\\s#])","end":"(\\s*)(?=[\\n;&)])","endCaptures":{"1":{"name":"meta.function-call.fish"}},"patterns":[{"comment":"Match the first command of a potential chain","name":"meta.function-call.fish","begin":"(?x)\n(?# Negative lookahead for piping)\n(?!\n  (?:(?:[0-9]+)?(?:<|>>?|\\^\\^?))?\\|\n)","end":"(?x)\n(?# Look ahead for control operations after whitespace)\n(?=\\s*\n  (?:\n    (?# Find simple control operations)\n    [\\n;&)]\n  |\n    (?# Find piping)\n    (?:(?:[0-9]+)?(?:<|>>?|\\^\\^?))?\\|\n  )\n)","patterns":[{"comment":"Pick up the command call"},{"include":"#command-call-meta"},{"include":"#command-call-standard"}]},{"comment":"Match a second or later command of a chain, starting with the connective piping","name":"meta.function-call.fish","begin":"(?x)\n(?# Look ahead for piping)\n(?=\n  (?:(?:[0-9]+)?(?:<|>>?|\\^\\^?))?\\|\n)","end":"(?=\\s*[\\n;&)])","patterns":[{"comment":"Match a pipe not followed by a command, hence a malformed segment of the chain","begin":"(?x)\n(?# Look ahead for piping followed by either control operators or piping)\n(?=\n  (?:(?:[0-9]+)?(?:<|>>?|\\^\\^?))?\\|\n  \\s*\n  (?:\n    [\\n;&)]\n  |\n    (?:(?:[0-9]+)?(?:<|>>?|\\^\\^?))?\\|\n  )\n)","end":"(?=\\s*[\\n;&)])","patterns":[{"comment":"If the command chain would end implicitly (ie, with a newline or close parenthesis), then mark the pipe itself invalid","name":"invalid.illegal.operator.fish","match":"(?:(?:[0-9]+)?(?:<|>|>>))?\\|(?=\\s*[\\n)])"},{"comment":"If the command chain would end with an explicit operator or encounter a second set of piping, then mark the first set of piping as valid and beyond as invalid","match":"(?x)\n(?# Consume valid piping; captures 1 2 3)\n(?:([0-9]+)?(<|>>?|\\^\\^?))?(\\|)\n(?# Consume whitespace)\n\\s*\n(?# Consume remainder; capture 4)\n(.*)","captures":{"1":{"name":"meta.pipe.fish constant.numeric.file-descriptor.fish"},"2":{"name":"meta.pipe.fish keyword.operator.redirect.fish"},"3":{"name":"meta.pipe.fish keyword.operator.pipe.fish"},"4":{"name":"invalid.illegal.function-call.fish"}}}]},{"comment":"Pick up a legitimate pipe","name":"meta.pipe.fish","match":"(?:([0-9]+)?(<|>>?|\\^\\^?))?(\\|)","captures":{"1":{"name":"constant.numeric.file-descriptor.fish"},"2":{"name":"keyword.operator.redirect.fish"},"3":{"name":"keyword.operator.pipe.fish"}}},{"comment":"Pick up the command call"},{"include":"#line-continuation"},{"include":"#command-call-meta"},{"include":"#command-call-standard"}]}]}]},"command-call-meta":{"comment":"Check if the command is a builtin which takes another command as arguments, ie, a meta command. However, ignore the command if it is taking an option or being backgrounded/piped, as in such a case it behaves as a standard command and should be picked up by that scope instead; TODO - Better logic in the types of piping ignored","patterns":[{"comment":"These meta commands force their argument to behave as a standard command","begin":"(builtin|command|exec)\\b(?!\\s+[-&|])","beginCaptures":{"1":{"name":"support.function.fish"}},"end":"(?=[\\n;&)|])","patterns":[{"include":"#line-continuation"},{"include":"#command-call-standard"}]},{"comment":"This meta command acts as a unary operator on the command to the right, which can also be a meta command. It only applies to one command and stops at piping","begin":"(not)\\b(?!\\s+[-&|])","beginCaptures":{"1":{"name":"keyword.operator.word.fish"}},"end":"(?x)\n(?# Look ahead for control operations after whitespace)\n(?=\\s*\n  (?:\n    (?# Find simple control operations)\n    [\\n;&)]\n  |\n    (?# Find piping)\n    (?:(?:[0-9]+)?(?:<|>>?|\\^\\^?))?\\|\n  )\n)","patterns":[{"include":"#line-continuation"},{"include":"#command-call-meta"},{"include":"#command-call-standard"}]}]},"command-call-standard":{"comment":"Check if the command is any other legal command, ie, a standard command","patterns":[{"comment":"A command call can't be a comment, but this match will only be satisfied if the command is first after a pipe because comments are otherwise consumed earlier","name":"invalid.illegal.function-call.fish","begin":"\\#","end":"(?=[\\n)])"},{"comment":"Match an operator which cannot start a command call but does not stop the next characters from being interpreted as a command","name":"invalid.illegal.operator.fish","match":"(?:[&|<>^])"},{"comment":"Anonymous scope - A complete command comprising a name element and optional argument, redirection, and comment elements","begin":"(?=\\S)","end":"(?x)\n(?# Look ahead for control operations)\n(?=\n  (?:\n    (?# Find control operations)\n    [\\n;&)]\n  |\n    (?# Find piping)\n    (?:(?:[0-9]+)?(?:<|>>?|\\^\\^?))?\\|\n  )\n)","patterns":[{"comment":"Anonymous scope - A name or block element. If a block is found, everything up to the `end` command is captured here. Note that redirection and process expansion can't start the element","begin":"(?![\\s<>^%])","end":"(?=[\\s;&)|<>])","patterns":[{"comment":"Look for block structures","include":"#command-call-standard-block"},{"comment":"Look for loop/function control commands. We perform no checking on the validity of their scope (because only allowing them in the correct scope won't work if they are used within if-blocks) or arguments (because fish does that during execution not parsing)","match":"(?:break|continue|return)(?=[\\s;&)|<>])","captures":{"0":{"name":"keyword.control.fish"}}},{"comment":"Anonymous scope - A generic name element","begin":"(?!\\s)","end":"(?=[\\s;&)|<>])","patterns":[{"comment":"A command name can't contain a command substitution. We match the whole line if no closing parenthesis is found, or until the end of the command name if the command substitution gets closed; fish would match the whole command name invalid if there was a command substitution anywhere in it, but we can't look ahead that effectively","name":"invalid.illegal.function-call.fish","begin":"(?=\\()","end":"(?=[\\s;&)|<>])","patterns":[{"begin":"\\(","end":"\\)|(?=[\\n;&)|<>])"}]},{"comment":"Treat the `set` command differently, capture modifier flags, and capture what immediately follows as a variable (being declared).","match":"\\b(set)\\s+(-l|-g|-x|-u|-U)*(l|g|x|u|U)*\\s*(--local\\s*|--global\\s*|--export\\s*|--unexport\\s*|--universal\\s*)*\\s*\\b(?<!-)((fish_escape_delay_ms|fish_greeting|fish_history|fish_user_paths|umask|BROWSER|CDPATH|LANG|LC_ALL|LC_COLLATE|LC_CTYPE|LC_MESSAGES|LC_MONETARY|LC_NUMERIC|LC_TIME|PATH|history|HOME|IFS|PWD|status|USER|CMD_DURATION|FISH_VERSION|SHLVL|COLUMNS|LINES|fish_color_normal|fish_color_command|fish_color_quote|fish_color_redirection|fish_color_end|fish_color_error|fish_color_param|fish_color_comment|fish_color_match|fish_color_search_match|fish_color_operator|fish_color_escape|fish_color_cwd|fish_color_autosuggestion|fish_color_user|fish_color_host|fish_color_cancel|fish_pager_color_prefix|fish_pager_color_completion|fish_pager_color_description|fish_pager_color_progress|fish_pager_color_secondary|ARFLAGS|CC|CFLAGS|CHARSET|DATEMSK|DEAD|EDITOR|ENV|EXINIT|FC|FCEDIT|FFLAGS|GET|GFLAGS|HISTFILE|HISTORY|HISTSIZE|LDFLAGS|LEX|LFLAGS|LINENO|LISTER|LOGNAME|LPDEST|MAIL|MAILCHECK|MAILER|MAILPATH|MAILRC|MAKEFLAGS|MAKESHELL|MANPATH|MBOX|MORE|MSGVERB|NLSPATH|NPROC|OLDPWD|OPTARG|OPTERR|OPTIND|PAGER|PPID|PRINTER|PROCLANG|PROCLANGARFLAGS|PROJECTDIR|PS1|PS2|PS3|PS4|RANDOM|SECONDS|SHELL|TERM|TERMCAP|TERMINFO|TMPDIR|TZ|VISUAL|YACC|YFLAGS)|\\w+)\\b","captures":{"1":{"name":"keyword.operator.assignment storage.type.fish"},"2":{"name":"storage.modifier.fish"},"3":{"name":"storage.modifier.fish"},"4":{"name":"storage.modifier.fish"},"5":{"name":"variable.other.fish"},"6":{"name":"variable.language.fish"}}},{"comment":"Check for special functions that serve as constants.","match":"\\b(true|false)\\b","captures":{"1":{"name":"constant.language.fish"}}},{"comment":"Check for special debug keyword.","match":"\\b(breakpoint)\\b","captures":{"1":{"name":"keyword.control.fish"}}},{"comment":"Check for special builtin fish functions (builtin -n).","match":"\\b(argparse|bg|bind|block|cd|commandline|complete|count|disown|echo|emit|exit|fg|functions|history|jobs|printf|pwd|random|read|realpath|set_color|source|status|string|test|ulimit)\\b","captures":{"1":{"name":"support.function.fish support.function.builtin.fish"}}},{"comment":"Check for special reserved fish functions (ls /usr/share/fish/functions/ | grep \"^_.*\").","match":"\\b(_|__fish_append|__fish_bind_test1|__fish_bind_test2|__fish_cancel_commandline|__fish_commandline_is_singlequoted|__fish_commandline_test|__fish_complete_abook_formats|__fish_complete_ant_targets|__fish_complete_atool_archive_contents|__fish_complete_bittorrent|__fish_complete_blockdevice|__fish_complete_cd|__fish_complete_command|__fish_complete_convert_options|__fish_complete_directories|__fish_complete_file_url|__fish_complete_ftp|__fish_complete_groups|__fish_complete_job_pids|__fish_complete_list|__fish_complete_lpr|__fish_complete_lpr_option|__fish_complete_lsusb|__fish_complete_man|__fish_complete_mount_opts|__fish_complete_path|__fish_complete_pgrep|__fish_complete_pids|__fish_complete_ppp_peer|__fish_complete_proc|__fish_complete_setxkbmap|__fish_complete_ssh|__fish_complete_subcommand|__fish_complete_subcommand_root|__fish_complete_suffix|__fish_complete_svn_diff|__fish_complete_tar|__fish_complete_unrar|__fish_complete_user_at_hosts|__fish_complete_users|__fish_complete_wvdial_peers|__fish_config_interactive|__fish_contains_opt|__fish_crux_packages|__fish_cursor_1337|__fish_cursor_konsole|__fish_cursor_xterm|__fish_describe_command|__fish_filter_ant_targets|__fish_git_prompt|__fish_gnu_complete|__fish_hg_prompt|__fish_is_first_token|__fish_is_git_repository|__fish_is_token_n|__fish_list_current_token|__fish_make_completion_signals|__fish_man_page|__fish_move_last|__fish_no_arguments|__fish_not_contain_opt|__fish_number_of_cmd_args_wo_opts|__fish_paginate|__fish_ports_dirs|__fish_print_abook_emails|__fish_print_addresses|__fish_print_arch_daemons|__fish_print_cmd_args|__fish_print_cmd_args_without_options|__fish_print_commands|__fish_print_debian_apache_confs|__fish_print_debian_apache_mods|__fish_print_debian_apache_sites|__fish_print_debian_services|__fish_print_encodings|__fish_print_filesystems|__fish_print_function_prototypes|__fish_print_help|__fish_print_hostnames|__fish_print_interfaces|__fish_print_lpr_options|__fish_print_lpr_printers|__fish_print_lsblk_columns|__fish_print_make_targets|__fish_print_modules|__fish_print_mounted|__fish_print_ninja_targets|__fish_print_ninja_tools|__fish_print_packages|__fish_print_pacman_repos|__fish_print_service_names|__fish_print_svn_rev|__fish_print_users|__fish_print_VBox_vms|__fish_print_xdg_applications_directories|__fish_print_xdg_desktop_file_ids|__fish_print_xdg_mimetypes|__fish_print_xrandr_modes|__fish_print_xrandr_outputs|__fish_print_xwindows|__fish_prt_no_subcommand|__fish_prt_packages|__fish_prt_ports|__fish_prt_use_package|__fish_prt_use_port|__fish_pwd|__fish_seen_subcommand_from|__fish_set_locale|__fish_sgrep|__fish_shared_key_bindings|__fish_svn_prompt|__fish_systemctl_automounts|__fish_systemctl_devices|__fish_systemctl_mounts|__fish_systemctl_scopes|__fish_systemctl_service_paths|__fish_systemctl_services|__fish_systemctl_slices|__fish_systemctl_snapshots|__fish_systemctl_sockets|__fish_systemctl_swaps|__fish_systemctl_targets|__fish_systemctl_timers|__fish_systemd_machine_images|__fish_systemd_machines|__fish_test_arg|__fish_toggle_comment_commandline|__fish_use_subcommand|__fish_vcs_prompt|__terlar_git_prompt|_validate_int)\\b","captures":{"1":{"name":"support.function.fish support.function.script.fish"}}},{"comment":"Check for special included fish functions (ls /usr/share/fish/functions/ | grep -v \"^_.*\") (and fish documentation).","match":"\\b(abbr|alias|cdh|dirh|dirs|eval|fish|fish_breakpoint_prompt|fish_config|fish_indent|fish_key_reader|fish_mode_prompt|fish_opt|fish_prompt|fish_right_prompt|fish_update_completions|fish_vi_mode|funced|funcsave|help|isatty|math|nextd|open|popd|prevd|prompt_pwd|psub|pushd|suspend|trap|type|umask|vared|contains_seq|delete-or-exit|down-or-search|edit_command_buffer|export|fish_clipboard_copy|fish_clipboard_paste|fish_default_key_bindings|fish_default_mode_prompt|fish_fallback_prompt|fish_hybrid_key_bindings|fish_md5|fish_vi_cursor|fish_vi_key_bindings|grep|hostname|la|ll|ls|man|nextd-or-forward-word|N_|prevd-or-backward-word|prompt_hostname|seq|setenv|up-or-search)\\b","captures":{"1":{"name":"support.function.fish support.function.included.fish"}}},{"comment":"Check for special unix functions (IEEE-Std-1003.1-2017).","match":"\\b(colon|dot|readonly|shift|times|unset|admin|ar|asa|at|awk|basename|batch|bc|c99|cal|cat|cflow|chgrp|chmod|chown|cksum|cmp|comm|compress|cp|crontab|csplit|ctags|cut|cxref|date|dd|delta|df|diff|dirname|du|ed|env|ex|expand|expr|fc|file|find|fold|fort77|fuser|gencat|get|getconf|getopts|hash|head|iconv|id|ipcrm|ipcs|join|kill|lex|link|ln|locale|localedef|logger|logname|lp|m4|mailx|make|mesg|mkdir|mkfifo|more|mv|newgrp|nice|nl|nm|nohup|od|paste|patch|pathchk|pax|pr|prs|ps|qalter|qdel|qhold|qmove|qmsg|qrerun|qrls|qselect|qsig|qstat|qsub|renice|rm|rmdel|rmdir|sact|sccs|sed|sh|sleep|sort|split|strings|strip|stty|tabs|tail|talk|tee|time|touch|tput|tr|tsort|tty|unalias|uname|uncompress|unexpand|unget|uniq|unlink|uucp|uudecode|uuencode|uustat|uux|val|vi|wait|wc|what|who|write|xargs|yacc|zcat)\\b","captures":{"1":{"name":"support.function.fish support.function.unix.fish"}}},{"comment":"Otherwise, treat the element as a fraction of a name made of arbitrary strings (which breaks at an escaped newline)","name":"variable.function.fish","begin":"(?!\\s)","end":"(?=[\\s;&()|<>])","patterns":[{"comment":"The string scope explicitly forbids '$' so that the argument rule can pick it up as a variable expansion, but '$' is treated as a literal in command names, so we have to match it separately","name":"meta.string.unquoted.fish","match":"\\$"},{"include":"#string"}]}]}]},{"comment":"A command name can't begin with a process expansion operator (however the variable expansion operator '$' is allowed)","name":"invalid.illegal.function-call.fish","begin":"\\%","end":"(?=[\\s;&)|<>])","patterns":[{"include":"#string"}]},{"comment":"Redirection can immediately follow the command name, without whitespace separation"},{"include":"#redirection"},{"comment":"Anonymous scope - A list of argument, redirection, or comment elements. We rely on this list being separated from the command name by whitespace; match any whitespace characters that aren't the newline","begin":"(?:[^\\n\\S]+)","end":"(?x)\n(?# Look ahead for control operations)\n(?=\n  (?:\n    (?# Find simple control operations)\n    [\\n;&)]\n  |\n    (?# Find piping)\n    (?:(?:[0-9]+)?(?:<|>>?|\\^\\^?))?\\|\n  )\n)","patterns":[{"comment":"A list of elements that does not start with an end-of-options argument","begin":"(?!--[\\s;&)|<>])","end":"(?x)\n(?# Look ahead for control operations or the end of options)\n(?=\n  (?:\n    (?# Find simple control operations)\n    [\\n;&)]\n  |\n    (?# Find piping)\n    (?:(?:[0-9]+)?(?:<|>>?|\\^\\^?))?\\|\n  |\n    (?# Find a double dash)\n    --[\\s;&)|<>]\n  )\n)","patterns":[{"include":"#line-continuation"},{"include":"#comment-internal-end"},{"include":"#redirection"},{"include":"#argument"}]},{"comment":"A list of elements that starts with an end-of-options argument","begin":"(?=--[\\s;&)|<>])","end":"(?x)\n(?# Look ahead for control operations)\n(?=\n  (?:\n    (?# Find simple control operations)\n    [\\n;&)]\n  |\n    (?# Find piping)\n    (?:(?:[0-9]+)?(?:<|>>?|\\^\\^?))?\\|\n  )\n)","patterns":[{"comment":"Contain just the end-of-options argument and give it the normal scope","begin":"(?=--[\\s;&)|<>])","end":"(?=[\\s;&)|<>])","patterns":[{"include":"#argument"}]},{"comment":"A list of elements (now using forcibly nonoption arguments)","begin":"(?=\\s)","end":"(?x)\n(?# Look ahead for control operations)\n(?=\n  (?:\n    (?# Find simple control operations)\n    [\\n;&)]\n  |\n    (?# Find piping)\n    (?:(?:[0-9]+)?(?:<|>>?|\\^\\^?))?\\|\n  )\n)","patterns":[{"include":"#line-continuation"},{"include":"#comment-internal-end"},{"include":"#redirection"},{"include":"#argument-nonoption"}]}]}]}]}]},"command-call-standard-block":{"patterns":[{"comment":"Block commands cannot be backgrounded, piped, or redirected","match":"(begin|while|if|for|switch|function)\\s*([&|<>])","captures":{"1":{"name":"variable.function.fish"},"2":{"name":"invalid.illegal.operator.fish"}}},{"comment":"The begin command uniquely cannot be the last command in a command substitution","match":"(begin)\\s*(\\))","captures":{"1":{"name":"variable.function.fish"},"2":{"name":"invalid.illegal.operator.fish"}}},{"comment":"The begin command can be alone on a line or followed by any command that doesn't start with a '-'. If a '-' is seen it shouldn't be treated as a block","name":"meta.block.begin.fish","begin":"begin(?=\\s*[\\n;]|\\s+[^\\s-])","beginCaptures":{"0":{"name":"keyword.control.conditional.fish"}},"end":"end(?=$|[\\s;&)|<>])","endCaptures":{"0":{"name":"keyword.control.conditional.fish"}},"patterns":[{"include":"$self"}]},{"name":"meta.block.while.fish","begin":"(?=while\\s+[^\\s;)-])","comment":"If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope","end":"end(?=$|[\\s;&)|<>])","endCaptures":{"0":{"name":"keyword.control.conditional.fish"}},"patterns":[{"comment":"Anonymous scope - Capture the command name we know is there, include a single instance of a command chain, and end when an operator is seen","begin":"while","beginCaptures":{"0":{"name":"keyword.control.conditional.fish"}},"end":"\\s*(?=[\\n;&)])","patterns":[{"include":"#line-continuation"},{"include":"#command-chain"}]},{"comment":"Anonymous scope - Capture the operator we know is there, include the base scope, and end when an `end` command is seen","begin":"\\n|(;)|([&)])","beginCaptures":{"1":{"name":"keyword.operator.fish"},"2":{"name":"invalid.illegal.operator.fish"}},"end":"(?=end(?:$|[\\s;&)|<>]))","patterns":[{"include":"$self"}]}]},{"name":"meta.block.if.fish","begin":"(?=if\\s+[^\\s;)-])","comment":"If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope","end":"end(?=$|[\\s;&)|<>])","endCaptures":{"0":{"name":"keyword.control.conditional.fish"}},"patterns":[{"comment":"Note that this internal scope does not treat the closing parenthesis as an operator, because a command substitution can't end in the middle of a block"},{"include":"#command-call-standard-block-if-internal"}]},{"name":"meta.block.for-in.fish","begin":"(?=for\\s+[^\\s;)-])","comment":"If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope","end":"end(?=$|[\\s;&)|<>])","endCaptures":{"0":{"name":"keyword.control.conditional.fish"}},"patterns":[{"comment":"Anonymous scope - Capture the command name we know is there, include a single instance of an argument (the varname), and end when the whitespace after the varname is captured","begin":"(for)(?:\\s+)","beginCaptures":{"1":{"name":"keyword.control.conditional.fish"}},"end":"\\s+","patterns":[{"include":"#line-continuation"},{"comment":"Presumably this is the varname","name":"variable.other.fish","match":"(\\b\\w+\\b)"},{"include":"#argument"},{"comment":"Capture anything that an argument explicitly rejects, which is mostly operators","name":"invalid.illegal.operator.fish","match":"\\S+"}]},{"comment":"Line continuation is allowed between the varname and \"in\"","include":"#line-continuation"},{"comment":"Anonymous scope - Capture the command name which might be there, include an arbitrary number of (forcibly nonoption) arguments, and end when the control operator is seen","begin":"in(?=\\s)","beginCaptures":{"0":{"name":"keyword.control.conditional.fish"}},"end":"\\s*(?=[\\n;&)])","patterns":[{"include":"#line-continuation"},{"include":"#comment-internal-end"},{"include":"#argument-nonoption"}]},{"comment":"Anonymous scope - Capture the operator we know is there, include the base scope, and end when an `end` command is seen","begin":"\\n|(;)|([&)])","beginCaptures":{"1":{"name":"keyword.operator.fish"},"2":{"name":"invalid.illegal.operator.fish"}},"end":"(?=end(?:$|[\\s;&)|<>]))","patterns":[{"include":"$self"}]},{"comment":"Anything beside line continuation, \"in\", or a control operator is invalid","name":"invalid.illegal.function-call.fish","match":"\\S+?(?=[\\s;&)])"}]},{"name":"meta.block.switch.fish","begin":"(?=switch\\s+[^\\s;)-])","comment":"If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope","end":"end(?=$|[\\s;&)|<>])","endCaptures":{"0":{"name":"keyword.control.conditional.fish"}},"patterns":[{"comment":"Anonymous scope - Match the valid part of the switch statement, then look for an invalid part","begin":"(?=switch)","end":"\\s*(?=[\\n;&)])","patterns":[{"comment":"Anonymous scope - Capture the command name we know is there, include a single instance of an argument (the value), and end when whitespace or a control operator is seen","begin":"(switch)(?:\\s+)","beginCaptures":{"1":{"name":"keyword.control.conditional.fish"}},"end":"(?=[\\s;&)])","patterns":[{"include":"#line-continuation"},{"include":"#argument"},{"comment":"Capture anything that an argument explicitly rejects, which is mostly operators","name":"invalid.illegal.operator.fish","match":"\\S+"}]},{"comment":"Anonymous scope - Capture whitespace which might be there, match any non-control-operator strings as invalid, and end when a control operator is seen","begin":"\\s+","end":"(?=[\\n;&)])","patterns":[{"name":"invalid.illegal.string.fish","match":"\\S+?(?=[\\s;&)])"}]}]},{"comment":"Anonymous scope - Capture the operator we know is there, include the base scope, and end when an `end` command is seen","begin":"\\n|(;)|([&)])","beginCaptures":{"1":{"name":"keyword.operator.fish"},"2":{"name":"invalid.illegal.operator.fish"}},"end":"(?=end(?:$|[\\s;&)|<>]))","patterns":[{"comment":"Anonymous scope - Capture the command name which might be there, include an arbitrary number of (forcibly nonoption) arguments, and end when the control operator is captured","begin":"case(?=[\\s;&)])","beginCaptures":{"0":{"name":"keyword.control.conditional.fish"}},"end":"\\n|(;)|([&)])","endCaptures":{"1":{"name":"keyword.operator.fish"},"2":{"name":"invalid.illegal.operator.fish"}},"patterns":[{"include":"#line-continuation"},{"include":"#comment-internal-end"},{"include":"#argument-nonoption"},{"comment":"Anything else (eg, redirection) is illegal","name":"invalid.illegal.operator.fish","match":"\\S+?(?=[\\s;&)])"}]},{"include":"$self"}]}]},{"name":"meta.block.function.fish","begin":"(?=function\\s+[^\\s;)-])","comment":"If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope","end":"end(?=$|[\\s;&)|<>])","endCaptures":{"0":{"name":"keyword.control.conditional.fish"}},"patterns":[{"comment":"Anonymous scope - Match the defined name of the function statement, then look for further arguments","begin":"(?=function)","end":"\\s*(?=[\\n;&)])","patterns":[{"comment":"Anonymous scope - Capture the command name we know is there, include a single instance of an argument (the value), and end when whitespace or a control operator is seen","begin":"(function)(?:\\s+)","beginCaptures":{"1":{"name":"storage.type.function.fish"}},"end":"(?=[\\s;&)])","patterns":[{"include":"#line-continuation"},{"name":"invalid.illegal.string.fish","begin":"(?:[()|<>])","end":"(?=[\\s;&)])"},{"comment":"Anonymous scope - Start when an escaped newline isn't present, and end when whitespace or a control operator is seen","begin":"(?!\\\\\\n)","end":"(?=[\\s;&()|<>])","patterns":[{"comment":"These patterns are similar to the scope around variable.function.fish in command-call-standard, except the defined name is expanded as an argument"},{"name":"entity.name.function.fish","begin":"(?!\\s)","end":"(?=[\\s;&()|<>])","patterns":[{"include":"#argument"}]}]}]},{"comment":"Anonymous scope - Capture whitespace which might be there, then match anything normal for a command call","begin":"\\s+","end":"(?=[\\n;&)])","patterns":[{"include":"#line-continuation"},{"include":"#comment-internal-end"},{"include":"#redirection"},{"include":"#argument"}]}]},{"comment":"Anonymous scope - Capture the operator we know is there, include the base scope, and end when an `end` command is seen","begin":"\\n|(;)|([&)])","beginCaptures":{"1":{"name":"keyword.operator.fish"},"2":{"name":"invalid.illegal.operator.fish"}},"end":"(?=end(?:$|[\\s;&)|<>]))","patterns":[{"include":"$self"}]}]}]},"command-call-standard-block-if-internal":{"comment":"The acceptable structure internal to an if-end block can be represented recursively because anonymous scopes nest silently. If an `else` without a following `if` is seen, then further `else` commands will be correctly marked as invalid. This is a lot of work just to get that extra little bit of functionality :)","patterns":[{"comment":"Anonymous scope - Capture an `if` and the command up to the end-of-scope operator, then capture from the end-of-scope operator indefinitely","begin":"(?=if(?:\\s*\\n|\\s+[^\\s;]))","end":"(?=end(?:$|[\\s;&)|<>]))","patterns":[{"comment":"Anonymous scope - Match the command name we know is there, include a single instance of a command chain, and end when an operator is seen","begin":"if","beginCaptures":{"0":{"name":"keyword.control.conditional.fish"}},"end":"\\s*(?=[\\n;&])","patterns":[{"include":"#line-continuation"},{"include":"#command-chain"}]},{"comment":"Anonymous scope - Match the operator we know is there, then include the base scope or an `else` structure","begin":"\\n|(;)|(&)","beginCaptures":{"1":{"name":"keyword.operator.fish"},"2":{"name":"invalid.illegal.operator.fish"}},"end":"(?=end(?:$|[\\s;&)|<>]))","patterns":[{"comment":"Anonymous scope - Capture an `else` up to the end-of-scope operator or the start of an `if` structure, then match from the end-of-scope operator indefinitely or match an `if` structure","begin":"(?=else\\s*[\\s;])","end":"(?=end(?:$|[\\s;&)|<>]))","patterns":[{"comment":"Anonymous scope - Match the `else` we know is there and any comment, and mark anything besides an `if` as illegal","begin":"else(?=\\s*[\\s;])","beginCaptures":{"0":{"name":"keyword.control.conditional.fish"}},"end":"\\s*(?=[\\n;&]|if(?:\\s*\\n|\\s+[^\\s;]))","endCaptures":{"1":{"name":"keyword.operator.fish"},"2":{"name":"invalid.illegal.operator.fish"}},"patterns":[{"include":"#line-continuation"},{"include":"#comment-internal-end"},{"comment":"Anything else is illegal","name":"invalid.illegal.string.fish","match":"\\S+?(?=[\\s;&])"}]},{"comment":"Anonymous scope - Match the operator which will be there if no `if` was seen, then include the base scope which marks further `else` commands as invalid","begin":"\\n|(;)|(&)","beginCaptures":{"1":{"name":"keyword.operator.fish"},"2":{"name":"invalid.illegal.operator.fish"}},"end":"(?=end(?:$|[\\s;&)|<>]))","patterns":[{"include":"$self"}]},{"comment":"Match the `if` structure which will be there if no operator was seen"},{"include":"#command-call-standard-block-if-internal"}]},{"include":"$self"}]}]}]},"command-substitution":{"patterns":[{"comment":"Capture \"(...)\" or \"(...)[...]\"","begin":"(?=\\()","end":"(?<=\\))(?![\\(\\[])|(?<=\\])(?!\\()","patterns":[{"name":"meta.parens.command-substitution.fish","begin":"\\(","beginCaptures":{"0":{"name":"punctuation.section.parens.begin.fish"}},"end":"\\)","endCaptures":{"0":{"name":"punctuation.section.parens.end.fish"}},"patterns":[{"comment":"The inside of a command substitution is indistinguishable from a global scope","include":"$self"}]},{"include":"#index-expansion"}]}]},"comment-external":{"patterns":[{"comment":"A full or inline comment outside of any command call","name":"comment.line.external.fish","begin":"\\#","beginCaptures":{"0":{"name":"punctuation.definition.comment.fish"}},"end":"\\n"}]},"comment-internal-end":{"patterns":[{"comment":"An inline comment at the end of a command call. Does not consume the newline, thus allowing the command call to capture it and end","name":"comment.line.internal.end.fish","begin":"\\#","beginCaptures":{"0":{"name":"punctuation.definition.comment.fish"}},"end":"(?=\\n)"}]},"index-expansion":{"patterns":[{"name":"meta.brackets.index-expansion.fish","comment":"Note also that command substitution can only have a single index expansion; the number of index expansion argument lists `[...]` should always be less than or equal to the number of variable expansion operators `$`. Unfortunately, we can do nothing to moderate that with this syntax schema; with a *.sublime-syntax and a scope stack it could be done. As it stands, \"$$foo[...]\" is the deepest that we can accurately highlight; in other words, the anonymous scope which contains the variable and the index expansion argument list should only be allowed to contain a single copy of each of those two things. We cannot enforce that without a scope stack. Our workaround is to allow an infinite number of these and hope the user can keep track of when there are too many","begin":"\\[","beginCaptures":{"0":{"name":"punctuation.section.brackets.begin.fish"}},"end":"\\]","endCaptures":{"0":{"name":"punctuation.section.brackets.end.fish"}},"patterns":[{"name":"keyword.operator.fish","match":"\\.\\."},{"include":"#command-substitution"},{"include":"#variable-expansion"},{"comment":"Manually recreate the string rule with a numeric match, extra logic in unquoted strings, and don't repeat the meta.string.unquoted scope"},{"include":"#string-quoted"},{"name":"constant.numeric.fish","match":"(?:[+-]?[0-9]+)(?=[\\s;&)|<>]|\\]|\\.\\.)"},{"begin":"(?![\\s'\"]|\\.\\.)","end":"(?=[\\s;&)|<>'\"]|\\]|\\.\\.)","comment":"Begin/end string as before with the addition of breaking at a ']' or \"..\"","patterns":[{"include":"#string-unquoted-patterns"}]}]}]},"line-continuation":{"comment":"This rule should be included anywhere that escaping a newline and adding an arbitrary number of comment lines is permitted (which is pretty much everywhere in fish)","patterns":[{"comment":"Consume any number of alternating escaped newlines and lines which have nothing on them but comments; end when the first character of a line isn't whindex-expansionitespace or a comment character or the escaped newline itself, or if the next character aftindex-expansioner some consumed whitespace isn't more whitespace or a comment character","begin":"(?=\\\\\\n)","end":"^(?![\\s\\#\\\\])|\\s(?![\\s\\#])","patterns":[{"name":"constant.character.escape","match":"\\\\\\n"},{"name":"comment.line.continuation.fish","begin":"\\#","beginCaptures":{"0":{"name":"punctuation.definition.comment.fish"}},"end":"\\n"}]}]},"redirection":{"patterns":[{"comment":"This redirection pattern connects a file descriptor (either explicit or implied) and a file descriptor. As the '&' is necessary, this is a more strict pattern match and must be attended to first; begin at any of the redirections valid for a file descriptor (the '&' must be present). Note that the stderr redirection operator '^' must be preceded by whitespace and cannot be preceded by a file descriptor; end at anything that would end an argument, with the added condition that the character before the boundary cannot be the final character of the begin match or whitespace, thus allowing an arbitrary amount of whitespace between the begin match and the integer found before the end match","name":"meta.redirection.fish","begin":"(?:([0-9]+)(<|>|>>)|(>>|\\^\\^|[<>]|(?<=^|\\s)\\^))(\\&)","beginCaptures":{"1":{"name":"constant.numeric.file-descriptor.fish"},"2":{"name":"keyword.operator.redirect.fish"},"3":{"name":"keyword.operator.redirect.fish"},"4":{"name":"keyword.operator.redirect.dereference.fish"}},"end":"(?<=[^&\\s]|\\n)(?=[\\s);&|<>])","patterns":[{"include":"#line-continuation"},{"comment":"Evaluates to a string which may be an integer","include":"#command-substitution"},{"comment":"Evaluates to a string which may be an integer","include":"#variable-expansion"},{"name":"constant.numeric.file-descriptor.fish","match":"(?:[0-9]+)(?=[\\s);&|<>])"},{"name":"keyword.operator.redirect.close.fish","match":"(?:-)(?=[\\s);&|<>])"},{"comment":"Anything else is illegal","name":"invalid.illegal.file-descriptor.fish","match":"(?:\\S+.*)$"}]},{"comment":"This redirection pattern connects a file descriptor (either explicit or implied) and a file path; Begin at any of the redirections valid for a file path (the '?' may optionally be used to prevent clobber). Note that the stderr redirection operator '^' must be preceded by whitespace and cannot be preceded by a file descriptor; end at anything that would end an argument, with the added condition that the character before the boundary cannot be the final character of the begin match or whitespace, thus allowing an arbitrary amount of whitespace between the begin match and the path found before the end match","name":"meta.redirection.fish","begin":"(?:([0-9]+)(<|>|>>)|(>>|\\^\\^|[<>]|(?<=^|\\s)\\^))(\\?)?","beginCaptures":{"1":{"name":"constant.numeric.file-descriptor.fish"},"2":{"name":"keyword.operator.redirect.fish"},"3":{"name":"keyword.operator.redirect.fish"},"4":{"name":"keyword.operator.redirect.clobber-test.fish"}},"end":"(?<=[^<>^?\\s]|\\n)(?=[\\s);&|<>])|(?=\\n)","patterns":[{"include":"#line-continuation"},{"comment":"Evaluates to a string so path cannot begin with '('","include":"#command-substitution"},{"comment":"Evaluates to a string so path cannot begin with '$'","include":"#variable-expansion"},{"comment":"Check for characters which are associated with redirection, so path cannot begin with them","name":"invalid.illegal.path.fish","match":"(?:(?:[&?]|[0-9]*[<>^]).*)$"},{"comment":"Use the function call match to build a file path, as the syntax is fairly similar (possibly identical, with exceptions caught above)","name":"meta.path.fish","match":"(?:\\'(?:\\\\[\\'\\\\]|[^\\'\\\\])*\\'|\\\"(?:\\\\[\\\"$\\n\\\\]|[^\\\"$\\n\\\\])*\\\"|(?:\\\\[abefnrtv $\\\\*?#(){}\\[\\]<>^&;|\"']|(?<=^|\\s)\\\\[~%]|\\\\[xX][0-9A-Fa-f]{1,2}|\\\\[0-7]{1,3}|\\\\u[0-9A-Fa-f]{1,4}|\\\\U[0-9A-Fa-f]{1,8}|\\\\c[?-~]|[^\\s$\\\\*?~%#()<>&|;\"']|\\\\(?=[^abefnrtv\\s$\\\\*?#(){}\\[\\]<>^&;|\"'xXuUc])|(?<=\\S|\\\\ )\\\\\\n|(?<=\\S|\\\\ )[~%#])+)+"}]}]},"string":{"patterns":[{"include":"#string-quoted"},{"include":"#string-unquoted"}]},"string-quoted":{"patterns":[{"name":"string.quoted.single.fish","begin":"\\'","beginCaptures":{"0":{"name":"punctuation.definition.string.begin.fish"}},"end":"\\'","endCaptures":{"0":{"name":"punctuation.definition.string.end.fish"}},"patterns":[{"comment":"Only accepted escapes are \\' and \\\\","name":"constant.character.escape.fish","match":"\\\\[\\'\\\\]"}]},{"name":"string.quoted.double.fish","begin":"\\\"","beginCaptures":{"0":{"name":"punctuation.definition.string.begin.fish"}},"end":"\\\"","endCaptures":{"0":{"name":"punctuation.definition.string.end.fish"}},"patterns":[{"comment":"Only accepted escapes are \\<newline>, \\\", \\\\, and \\$","name":"constant.character.escape.fish","match":"\\\\[\\n\\\"\\\\$]"},{"comment":"Variable expansion is the only expansion accepted","include":"#variable-expansion"}]}]},"string-unquoted":{"patterns":[{"name":"meta.string.unquoted.fish","begin":"(?![\\s;&()|<>'\"$])","comment":"Begin unquoted string if not whitespace, control operator, quoted string, or variable expansion; end unquoted string at anything that can't be in one","end":"(?=[\\s;&()|<>'\"$])","patterns":[{"include":"#string-unquoted-patterns"}]}]},"string-unquoted-patterns":{"comment":"Describe contents of an unquoted string separately for ease of recursion","patterns":[{"comment":"This list follows the order given in official fish documentation, with the addition of additional checks made on the ~ and % characters which only need escaping if they appear at the front of an argument","name":"constant.character.escape.fish","match":"(?x)\n\\\\[abefnrtv $\\\\*?#(){}\\[\\]<>^&|;\"']\n|\n(?<=^|\\s)\\\\[~%]\n|\n\\\\[xX][0-9A-Fa-f]{1,2}\n|\n\\\\[0-7]{1,3}\n|\n\\\\u[0-9A-Fa-f]{1,4}\n|\n\\\\U[0-9A-Fa-f]{1,8}\n|\n\\\\c[?-~]"},{"comment":"Just for convenience we separate the newline escape","name":"constant.character.escape.fish","match":"\\\\\\n"},{"name":"meta.braces.brace-expansion.fish","begin":"\\{","beginCaptures":{"0":{"name":"punctuation.section.braces.begin.fish"}},"end":"\\}","endCaptures":{"0":{"name":"punctuation.section.braces.end.fish"}},"patterns":[{"name":"punctuation.section.braces.separator.fish","match":"\\,"},{"include":"#command-substitution"},{"include":"#variable-expansion"},{"comment":"Manually recreate the string rule with a numeric match, extra logic in unquoted strings, and don't repeat the meta.string.unquoted scope"},{"include":"#string-quoted"},{"name":"constant.numeric.fish","match":"(?:[+-]?)(?:[0-9]+\\.?[0-9]*|[0-9]*\\.?[0-9]+)(?=[\\s;&)|<>]|\\}|\\,)"},{"begin":"(?![\\s;&)|<>'\"])","end":"(?=[\\s;&)|<>'\"]|\\}|\\,)","comment":"Begin/end string as before with the addition of breaking at a '}' or ','","patterns":[{"name":"constant.character.escape.fish","match":"\\\\\\,"},{"include":"#string-unquoted-patterns"}]}]},{"name":"meta.wildcard-expansion.fish","match":"(\\*\\*)|(\\*)|(\\?)","captures":{"1":{"name":"keyword.operator.double-star.fish"},"2":{"name":"keyword.operator.single-star.fish"},"3":{"name":"keyword.operator.question-mark.fish"}}},{"comment":"Check for special argparse variables; TODO check for context within function declaration and presence of `argparse` if possible","match":"\\b(?<!-)(_flag_\\w+)\\b","captures":{"1":{"name":"variable.language.fish"}}}]},"variable-expansion":{"patterns":[{"include":"#variable-expansion-illegal"},{"comment":"Capture \"$foo\" or \"$foo[]\" or \"$$foo[][]\" etc","name":"meta.variable-expansion.fish","begin":"(?=\\$)","end":"(?<=[\\$\\w])(?=[^\\$\\w\\[])|(?<=\\])(?![\\$\\[])","patterns":[{"comment":"Match any depth of recursive variable expansions"},{"name":"variable.other.fish","begin":"\\$","beginCaptures":{"0":{"name":"punctuation.definition.variable.fish"}},"end":"(?<=[\\$\\w])(?=[^\\$\\w])","patterns":[{"comment":"Check for special `$argv` variable; TODO check for context within function declaration","match":"(argv)","captures":{"1":{"name":"variable.language.fish"}}},{"comment":"Check for special fish variables (fish documentation)","match":"(fish_escape_delay_ms|fish_greeting|fish_history|fish_user_paths|umask|BROWSER|CDPATH|LANG|LC_ALL|LC_COLLATE|LC_CTYPE|LC_MESSAGES|LC_MONETARY|LC_NUMERIC|LC_TIME|PATH|history|HOME|IFS|PWD|status|USER|CMD_DURATION|FISH_VERSION|SHLVL|COLUMNS|LINES|fish_color_normal|fish_color_command|fish_color_quote|fish_color_redirection|fish_color_end|fish_color_error|fish_color_param|fish_color_comment|fish_color_match|fish_color_search_match|fish_color_operator|fish_color_escape|fish_color_cwd|fish_color_autosuggestion|fish_color_user|fish_color_host|fish_color_cancel|fish_pager_color_prefix|fish_pager_color_completion|fish_pager_color_description|fish_pager_color_progress|fish_pager_color_secondary)","captures":{"1":{"name":"variable.language.fish"}}},{"comment":"Check for special UNIX variables (IEEE-Std-1003.1-2017)","match":"(ARFLAGS|CC|CFLAGS|CHARSET|DATEMSK|DEAD|EDITOR|ENV|EXINIT|FC|FCEDIT|FFLAGS|GET|GFLAGS|HISTFILE|HISTORY|HISTSIZE|LDFLAGS|LEX|LFLAGS|LINENO|LISTER|LOGNAME|LPDEST|MAIL|MAILCHECK|MAILER|MAILPATH|MAILRC|MAKEFLAGS|MAKESHELL|MANPATH|MBOX|MORE|MSGVERB|NLSPATH|NPROC|OLDPWD|OPTARG|OPTERR|OPTIND|PAGER|PPID|PRINTER|PROCLANG|PROCLANGARFLAGS|PROJECTDIR|PS1|PS2|PS3|PS4|RANDOM|SECONDS|SHELL|TERM|TERMCAP|TERMINFO|TMPDIR|TZ|VISUAL|YACC|YFLAGS)","captures":{"1":{"name":"variable.language.fish"}}},{"include":"#variable-expansion-illegal"},{"include":"#variable-expansion-simple"}]},{"comment":"Match any number of consecutive index expansions"},{"include":"#index-expansion"}]}]},"variable-expansion-simple":{"comment":"Describe variable expansion that has no index expansion separately","patterns":[{"name":"variable.other.fish","begin":"\\$","beginCaptures":{"0":{"name":"punctuation.definition.variable.fish"}},"end":"(?<=[\\$\\w])(?=[^\\$\\w])","patterns":[{"include":"#variable-expansion-illegal"},{"include":"#variable-expansion-simple"}]}]},"variable-expansion-illegal":{"comment":"Describe illegal variable expansions separately","patterns":[{"comment":"A lone '$' in a scope, or an attempt to expand a variable starting with a nonword character, is an error. These boundaries are the same as for meta.string.unquoted","name":"invalid.illegal.variable-expansion.fish","match":"\\$(?:(?=[,'\"\\]}\\s);&|])|[^\\w\\$][^$,'\"\\]}\\s);&|]*)"}]}},"firstLineMatch":"^#!.*\\b(fish)|^#\\s*-\\*-[^*]*mode:\\s*shell-script[^*]*-\\*-","foldingStartMarker":"\\b(begin|case|for|if|else|function|switch|while)\\b|(\\{)$","foldingStopMarker":"^\\s*(\\}|(case|else|end)\\b)","keyEquivalent":"^~F"}